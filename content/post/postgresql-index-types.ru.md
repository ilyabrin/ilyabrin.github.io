---
title: "Индексы в PostgreSQL"
date: 2025-03-01T13:01:14+01:00

author: "Ilya Brin"
categories: ['postgresql']
tags: ['sql', 'pg', 'postgresql', 'databases']
---

Представьте, что вы ищете любимую песню в старом mp3-плеере без плейлиста — крутите треки по одному, пока не наткнётесь на нужный. Это PostgreSQL без индексов: пыхтит, кряхтит и листает все строки в нашей огромной таблице. А теперь добавьте индексы — и вот у вас уже Spotify с мгновенным поиском! Быстро разберём, какие индексы есть в PostgreSQL, зачем они нужны и как превращают базу из черепахи в ракету. Плюс — парочка примеров из реальной жизни, чтобы прочувствовать разницу.

## Зачем нам эти индексы?

Допустим, у нас есть таблица `users` с миллионом человек, и мы хотим найти всех Петровых. Без индекса PostgreSQL устраивает марафон: пробегает каждую строку в поисках нужной фамилии. Вы уже допиваете вторую чашку чая, а результат всё где-то там, на горизонте. С индексом — бац! — и данные у вас за миллисекунды. Индексы ускоряют `SELECT`, `WHERE`, `JOIN`, а иногда даже `ORDER BY`. Это как телепорт для запросов! Но не всё так просто: за скорость приходится платить, и я расскажу, чем именно.

## Какие индексы есть в PostgreSQL?

PostgreSQL — как швейцарский нож с кучей лезвий. Вот его типы индексов:

**1.B-tree (сбалансированное дерево)**  

Король вечеринки! Надёжный, универсальный, как джинсы - на все случаи жизни. Отлично справляется с операторами `=`, `<`, `>`, диапазонами и сортировкой. Пишешь `CREATE INDEX` — получаешь `B-tree` по умолчанию.
*Пример*: В интернет-магазине вы ищете заказы за январь (`WHERE order_date > '2025-01-01'`). B-tree на `order_date` — и готово.

**2.Hash**  

Быстрый, как молния, но только для точных попаданий (`=`). Никаких тебе диапазонов или сортировок.
*Пример*: Проверяете промокод (`WHERE discount_code = 'FREEBEER'`). Hash-индекс в помощь!

**3.GIN (Generalized Inverted Index)**  

Хорош для поиска в JSON и текстового поиска. Это как Google внутри вашей базы.
*Пример*: Ищете посты в блоге с тегами `['котики', 'программирование']`. Создаем GIN на колонку с тегами — и вы уже листаете результаты.

**4. GiST (Generalized Search Tree)**  

Король геометрии и сложных задач. Нужны рестораны в радиусе 5 км? Окэй!
*Пример*: Пишешь приложение доставки с поиском ближайшей пиццерии. GiST знает, как это сделать быстро.

**5. BRIN (Block Range INdex)**  

Лёгкий, быстрый, занимает мало места - идеален для огромных таблиц с упорядоченными данными (например, по времени).
*Пример*: Логи сервера за год. BRIN на `log_time` — и запросы вроде `WHERE log_time > '2025-03-01'` летают.

**6. Уникальный индекс**  

Не тип, а скорее супергеройский плащ для B-tree. Следит, чтобы в колонке не было клонов.
*Пример*: `email` в таблице `users`. Один адрес — один хозяин, никаких дублей!

## Живые примеры: без индексов и с ними

**Без индекса: как черепаха на прогулке**
Есть таблица `orders` с 10 миллионами заказов. Хотим найти заказы юзера с `user_id = 42`. Запрос:

```sql
SELECT * FROM orders WHERE user_id = 42;
```

Без индекса PostgreSQL превращается в дотошного бухгалтера: проверяет каждый заказ, шепча "42... нет, 42... нет". 5 секунд — и вы уже думаете, не проще ли найти их вручную. Клиент зевает, приложение тормозит, а вы краснеете перед заказчиком.

**С индексом: как ракета на старте**
Добавляем:

```sql
CREATE INDEX idx_orders_user_id ON orders (user_id);
```

И — вуаля! Тот же запрос теперь занимает 0.01 секунды. PostgreSQL, как супергерой, ныряет прямо к нужным строкам. Пользователь в восторге, вы — в восторге, а база тихо мурлычет от счастья. Кайф!

**Ещё пример: охота за диапазоном**
Запрос `SELECT * FROM orders WHERE order_date BETWEEN '2025-01-01' AND '2025-01-31'` без индекса — это как искать иголку в стоге сена с завязанными глазами. С `B-tree` на `order_date` - скорость космическая!

## Почему индексы — это круто?

* **Скорость**: Запросы летают, а не ползают.  
* **Лёгкость**: Сервер не надрывается, а вы не тратите нервы.  
* **Счастье пользователей**: Пользователи не уходят из-за долгого ожидания.  

Но не всё так радужно. Индексы — это не конфетка, которую можно раздавать всем подряд.

## Когда индексы — это перебор?

* **Мини-таблицы**  
Если у вас 50 строк, PostgreSQL и без индекса справится быстрее, чем вы скажете "оптимизация запроса".  

* **Записи нон-стоп**  
Индексы обновляются при каждом `INSERT` или `UPDATE`. Если вы пишете логи каждую секунду, индекс будет только тормозить вечеринку.  

* **Все одинаковые**  
Колонка вроде `status = 'active'` у 99% записей? Индекс тут будет как зонтик в пустыне.  

* **Слишком много индексов**  
Индексы сами по себе тоже требуют дискового пространства и чем больше индексов у базы, тем больше она будет занимать места. Да и памяти тоже.

## Лайфхак: как не промахнуться с индексом?

* Запустите `EXPLAIN` на своём запросе. Видите `Seq Scan`? Это сигнал — нужен индекс!
* Для точных совпадений — Hash или B-tree.
* Диапазоны и сортировка — B-tree.
* JSON или массивы — вызывайте GIN.
* Огромные таблицы с порядком — BRIN поможет.

**Финальный аккорд**  
Индексы в PostgreSQL — это как нитро для базы данных: добавляете их в нужный момент, и база взлетает. Они превращают унылый поиск в захватывающий танец, где каждый шаг точен и быстр. Но без фанатизма: индексы — это приправа, а не основное блюдо. Используйте их с умом, и ваша база будет петь от радости, а пользователи — аплодировать стоя.
